\chapter{Developer documentation}
\label{ch:impl}

This chapter is dedicated to the developers and provides insights into the technical stack and implementation specifications. In \autoref{sec:D-env}, the possible development environment and tool versions are listed. The \autoref{sec:D-run} provides instructions on the local starting of the solution. In \autoref{sec:D-AppStructure} a total overview of the architecture of the project is attached, followed by \autoref{sec:D-db}, \autoref{sec:D-UI} and \autoref{sec:D-srv} which documented the data model, front-end and back-end accordingly. Right after comes \autoref{sec:D-security} where role specifications and mock user data are noted. Finally, \autoref{sec:D-testing} is inserted focusing on the testing of the solution. 

\section{Environment Requirements}
\label{sec:D-env}

The application uses the combination of Intellij \cite{intellij} locally (for java back-end development) and of SAP's cloud based development application, SAP Business Application Studio \cite{bas} with Full-Stack Development dev-space (for database and UI development).
For front-end development, UI5 framework \cite{ui5-toolkit} is used with fiori elements \cite{fiorielements} (more details in \ref{sec:D-UI}). 
For back-end development, CAP Java \cite{cap-about}\cite{cap-java} flavor is chosen.
Hence, for the local development, up to date Java JDK \cite{java}, node.js \cite{nodejs} and CAP extensions are hard requirements. 
The SAP Business Application Studio came with all required software and plugins, so no need for further configurations. The specific set up of Intellij can be found \href{https://github.com/SAP-samples/cloud-cap-samples-java\#using-intellij-idea-community-and-ultimate}{here} \cite{proj-setup-intellij}.
Firefox \cite{firefox} browser (on windows 11) and Safari \cite{safari} (on Mac OS) are used by the thesis for running the UI. The project also uses the maven build system \cite{maven}, which is preinstalled in SAP Business Application Studio (can be used from command line) and is supported by Intellij (can be used from application UI). 
A snapshot of versions at the time of development is attached (\autoref{src:1}). To install the project for local development, the developer can reference to \autoref{sec:GeneralRequisite} of the user's documentation.

\lstset{caption={Version check}, label=src:1}
\begin{lstlisting}[language={bash}]
> java --version
# openjdk 17.0.4.1 2022-08-12 LTS
# OpenJDK Runtime Environment SapMachine (build 17.0.4.1+1-LTS)
# OpenJDK 64-Bit Server VM SapMachine (build 17.0.4.1+1-LTS, mixed mode, sharing)
> cds version
# @sap/cds: 7.2.1
# @sap/cds-compiler: 4.0.2
# @sap/cds-dk: 7.2.0
# @sap/cds-dk (global): 7.2.0
# @sap/cds-fiori: 1.1.0
# @sap/cds-foss: 4.0.2
# @sap/cds-mtxs: 1.11.0
# @sap/eslint-plugin-cds: 2.6.3
# Node.js: v18.14.2
\end{lstlisting}

\section{Run}
\label{sec:D-run}

The following command starts up the project quickly. It watches any front-end and data model changes within the project and refreshes automatically. It is useful for UI development. Note that using this the Java back-end will not be included.

\lstset{caption={Run commands}, label=src:22}
\begin{lstlisting}[language={bash}]
cds watch 
\end{lstlisting}

To include the custom Java back-end added, the following commands from maven can be used to compile and start the project as a spring-boot application in the SAP Business Application Studio. In Intellij, the project can be started by first clicking at the install goal from the maven tab, and then the top level run button on the menu to start the spring-boot server at port 8084.
\begin{lstlisting}[language={bash}]
mvn clean install # Compile *.cds files and create gen folder.
mvn spring-boot:run # Start the server at port 8084
\end{lstlisting}

% -----------------------------------------------
% Project Structure
\section{Project Structure}
\label{sec:D-AppStructure}

The project is developed using CAP (Cloud Application Programming Model) \cite{cap-welcome} as the backbone. 
All three essential parts of the project, front-end, back-end and database model are being developed at the same place/project/root directory. 
The implementations and definitions located in different directories of the project are logically packaged into separate name spaces (name space in CDS, package declaration in Java) (See folder structure in \autoref{src:3}).

\begin{figure}[!htb]
	\centering
	\includegraphics[width=1\linewidth]{images/app_struct_new.jpg}
	\caption{Project Structure Overview}
	\label{fig:appStruct}
\end{figure}

% (\autoref{fig:packStruc})
In total, 6 micro applications are maintained and used by the parcel collection service (see \autoref{sec:BusinessContext}). This is designed, so the authorizations can be enforced application-wise (accessibility of a role to a specific application). Each application unit consists of a front-end application and a back-end service.
The back-end services all build upon the same CAP back-end implementation, which consumes database service through CAP's provided persistence service library \cite{cap-java-persistencesrv}. The front-end runs on the browser and communicates with back-end through the OData protocol \cite{odata} through HTTP \cite{http} (\autoref{fig:appStruct}). 


% \begin{figure}[H]
% 	\centering
% 	\includegraphics[height=400px]{images/Package_Diagram.png}
% 	\caption{Namespace Diagram}
% 	\label{fig:packStruc}
% \end{figure}


\lstset{caption={Base project folders}, label=src:3}
\begin{lstlisting}[language={bash}]
root/
    |- srv # contains back-end service related implementations
    |- db # contains data model definitions and initial data
    |- app # contains all Fiori front-end applications
\end{lstlisting}

The details of inner parts of each directory will be introduced later in corresponding sections.

\section{Data Model}
\label{sec:D-db}

The data model in this thesis is segregated into 2 parts (name space): \textbf{core} and \textbf{common}. 
The \textbf{core} space includes solution specific data models. The \textbf{common} space includes common data models that could be shared among multiple applications (out of this thesis scope) and are implemented only as proof of concept The full entity relationship diagram of the database schema of the project can be checked in \autoref{appx:diagram} - \autoref{fig:db}. 

% \subsection{Entity Relationship Diagram}

\subsection{CDL}
\label{subsec:db-cdl}
All data models are modeled by CDS' definition language (CDL) \cite{cap-cds-cdl}. Single entities are put into their own \textit{EntityName.cds} files. 
At compilation time, a \textit{schema.sql} is generated from the models in the root directory, which will contains the DDLs of generated tables in HANA SQL \cite{hanasql}. This file also includes the view generated for the services, explained in \autoref{subsubsec:D-srv-steps}.


The name spaces of the solution-specific and common data models are defined accordingly at the top of each entity definition.

\lstset{caption={cds name spaces for data model}, label=src:6}
\begin{lstlisting}[language={c++}]
// namespace for reused
namespace com.sap.internal.digitallab.packagehandling.common; 
// namespace for solution-specific
namespace com.sap.internal.digitallab.packagehandling.core; 
\end{lstlisting}


To optimize and standardize the outcome, common \textbf{aspects} (\textit{cuid, managed, User, CodeList}) from \textit{@sap/cds/common} are used in the definition. \cite{cap-cds-common-aspects} It can be seen as "extend" in the object-oriented way, or more specifically "interface" in Java. Aspects are defined in a similiar way as entities, they consist of fields/properties. Entities can "implement" zero to more aspects, "inheriting" aspect's properties and "extended" by their own properties. 

\begin{description}
    \item[CDS's aspects]\quote{"allow to flexibly extend definitions by new elements as well as overriding properties and annotations. They are based on a mix-in approach as known from aspect-oriented programming methods."} \cite{cap-cds-common-aspects}
\end{description}

Three common aspects are used by this thesis. \textit{managed} comes with 4 elements: created by, created on, changed by, changed on, and automatically updates them. \textit{cuid} automatically assigns UUID primary key to entity. \textit{CodeList} provides an out-of-box way of implementing enumeration like data structures and supports automatic localization.

\lstset{caption={Aspect managed from @sap/cds/common}, label=src:7}
\begin{lstlisting}[language={c++}]
aspect managed {
  createdAt: Timestamp @cds.on.insert: $now;
  createdBy: User      @cds.on.insert: $user;
  modifiedAt: Timestamp@cds.on.insert: $now  @cds.on.update: $now;
  modifiedBy: User     @cds.on.insert: $user @cds.on.update: $user;
}
\end{lstlisting}

\lstset{caption={Aspect cuid from @sap/cds/common}, label=src:8}
\begin{lstlisting}[language={c++}]
aspect cuid {
  key ID : UUID; //> automatically filled in
}
\end{lstlisting}

\lstset{caption={Aspect CodeList from @sap/cds/common}, label=src:9}
\begin{lstlisting}[language={c++}]
aspect CodeList @(
    cds.autoexpose,
    cds.persistence.skip : 'if-unused'
) {
    name  : localized String(255)  @title : '{i18n>Name}';
    descr : localized String(1000) @title : '{i18n>Description}';
}
\end{lstlisting}

Unique constraints are modeled with \textit{@assert.unique.<constraintName>} annotations \cite{cap-cds-common-annotations} at model level, enforcing uniqueness checks on all possible CREATE and UPDATE operations.
\autoref{src:10} shows how a unique constraint and the fields of the managed aspect are reflected by given a pair of example of CDL definitions and the according generated HANA SQL DDL.

\lstset{caption={managed, cuid delivery company entity with unique constraint and corresponding SQL DDL}, label=src:10}
\begin{lstlisting}[language={sql}]
@assert.unique: {nbunique: [name]}
entity EntityName : cuid, managed {
    name     : String(255) not null;
}
CREATE TABLE EntityName (
  ID NVARCHAR(36) NOT NULL,
  createdAt TIMESTAMP(7),
  createdBy NVARCHAR(255),
  modifiedAt TIMESTAMP(7),
  modifiedBy NVARCHAR(255),
  name NVARCHAR(255) NOT NULL,
  PRIMARY KEY(ID),
  CONSTRAINT core_EntityName_nbunique UNIQUE (name)
); 
\end{lstlisting}


In \autoref{src:11}, how the code list is implemented in normal SQL is illustrated. It can be observed that by implementing the \textit{CodeList} aspect, two fields, name and descr are added. In addition to this, the enum entity will be localization enabled, which means the displayed text at UI level will be translated according to the system language automatically.

\lstset{caption={codelist package type entity and corresponding SQL DDL}, label=src:11}
\begin{lstlisting}[language={sql}]
entity EnumEntity : sap.common.CodeList {
    key code : String(255) not null;
}
CREATE TABLE EnumEntity (
  name NVARCHAR(255),
  descr NVARCHAR(1000),
  code NVARCHAR(255) NOT NULL,
  PRIMARY KEY(code)
);
\end{lstlisting}


Extra virtual fields are defined with \textit{virtual} keyword. These fields are not included in the database schema (not saved physically in the database), but will be calculated on request by the service implementations. 
Extra calculated fields are defined with "\textit{=}" signed (\autoref{src:90}). These fields are not included in the database schema (not stored physically in the database), but are calculated dynamically from the attributes of one of the associated fields.
These two type of fields provide a short cut to frequently needed counts or fields, and they can be found (are grouped) at the bottom part of entity definitions.

\lstset{caption={Virtual and Calculated Field Syntax}, label=src:90}
\begin{lstlisting}[language={c++}]
virtual <vf>  : <Type>;
<cf>          : <Type> = <assoField>.<property>;
\end{lstlisting}


The correctness of the relationship implementation can be checked by running a command:

\lstset{caption={Generate schema from CDS view}, label=src:bash}
\begin{lstlisting}[language={bash}]
> cds compile ./db/models/common/ --to sql > schema.sql
\end{lstlisting}

The location of the schema definition files is illustrated below:
\lstset{caption={Structure of folders - data model}, label=src:4}
\begin{lstlisting}[language={bash}]
root/
    |- db/
        |- model
            |- packagehandling 
                |- *.cds # solution specific data models
            |- common
                |- *.cds # common data models
\end{lstlisting}

\section{UI}
\label{sec:D-UI}

The front-end of this thesis adapts the combination of SAP traditional UI5 framework (free-style UI application) and the state-of-the-art Fiori elements (template UI application) supported by CDS' annotation language. \cite{fiori-design} This chapter explains in details the used framework concepts and the structure of each module. The exact UX and behaviour of the UI applications should be referenced from \autoref{ch:user}.

\begin{description} 
	\item[SAP UI5] \quote{"is a JavaScript framework and UI library that helps developers create cross-platform enterprise-ready web applications in an efficient way. It features more than 500 UI controls aligned with the latest SAP Fiori design guidelines and comes with built-in support for data binding, routing, message handling, and more"}~\cite{ui5}.

\end{description}
\begin{description} 
	\item[SAP Fiori elements] \quote{"is a framework that comprises the most commonly used floorplan templates and is designed to:
         \begin{compactenum}
        	\item Speed up development by reducing the amount of front-end code needed to build SAP Fiori apps.
        	\item Drive UX consistency and compliance with the latest SAP Fiori design guidelines"~\cite{fiorielements}.
        \end{compactenum}}
      
\end{description}

\subsection{Front-end Architecture Overview}

\subsubsection{/app}

UI related modules are packed under \textit{root/app} folder of the project. There are 6 stand alone UI applications (modules) in total, corresponding to the 6 back-end service. Each application is named in the format of \textit{<action|entity>} and are initially generated using Fiori Application Generator, which creates basic skeletons of either free-style application or template application. 

A Fiori launchpad sandbox is configured under \textit{appconfig/fioriSandboxConfig.json}, which simulates the behaviour of the launchpad, provides a collection of application tiles and basic forward and backward navigation within the application. An \textit{index.html} file is also created at \textit{app/} level as the entry point of the launchpad.

Furthermore, \textit{index.cds} files are created at every level of folder, as an aggregation collection of the cds annotations over the application.

Model-View-Controller (MVC) concept is used in SAP UI5 development to keep the application data separate from the user interactions. This concept is natively adapted in free-style UIs and was kept, a little bit differently, in template UIs. The general structure of the both type of UI applications will be explained in the coming two sections. 

\subsubsection{Freestyle Module Explanation}
For a freestyle application, the main implementations are under the \textbf{webapp} folder. The solution adapts MVC architecture and hence split further into three parts/folders: \textbf{view}, \textbf{model} and \textbf{controller}. The \textbf{view} collects all the views used by the app. These "view templates" are defined in \textbf{xml} with filename \textbf{*.view.xml}. The \textbf{model} folder collects the functions in case any creation of "local data model" (local json data model not defined in the manifest but shall be used as part of bindings). Those are loaded upon opening the application at component.js. The \textbf{controller} folder contains controllers (one controller for one view) which respond to any user interaction event (e.g. a click on the button), collect necessary data and dispatch the event to corresponding back-end services.

It also contains three "descript" files: \textbf{index.html}, \textbf{Component.js} and \textbf{manifest.json}. \textbf{index.html} acts as the entry point of application.  \textbf{Component.js} inherits from SAP UI5 UIComponent and would register the entire application as a UI component on the Fiori launchpad based on the manifest and its init function. \textbf{manifest.json} specifies the module name, name space, service destination, service model, resources locations (css, images), and optionally some others, which will be constantly used when implementing the UI logics.

In case css or image resources are specified in the manifest, two folders \textbf{css} and \textbf{images} are also added under the specified path containing the necessary resources. Once configured under manifest, the css stylesheets and images can be used in all views under the same name space (root path).

Three other not so involved folders are \textbf{i18n} (in case of text translation), \textbf{test} (auto generated for local test), \textbf{localService} (puts in local mock metadata of the used back-end service).

\subsubsection{Template Module Explanation}

For a template application, the main implementations are under \textbf{webapp} (custom js implementations) and \textbf{annotations} (cds support for customizing Fiori elements templates \cite{fiori-showcase}\cite{fiori-design}\cite{fiori-toolkit}) folders.

Under the \textbf{webapp} collects almost the same set of folders / files as in the \textbf{webapp} of freestyle UIs. The main difference here is that there is no longer normal views (\textbf{view} folder) for the application, instead the common fiori element templates (List Report Page \& Object Page in this thesis) are defined in the \textbf{manifest.js}. Those templates are loaded from SAP UI5 standard library as the view of the application. They use their own standard controllers and would consume the entity data directly from the OData v2 / v4 models defined in the \textbf{manifest.json}. 

% Hence, the ordinary \textbf{model}, \textbf{view}, \textbf{controller} folders no longer exists directly \textbf{webapp}.

In most of the cases, custom actions / columns have to be added to the used templates (mostly as buttons). The location of action buttons / columns (within the template page) is defined in the \textbf{manifest.json}, while their business logics / representations are implemented under the \textbf{webapp/ext} folder. Here it splits into three more folders: \textbf{component} (the controllers for corresponding dialog fragments), \textbf{view} (the fragment xml of column or dialog used by the actions), \textbf{controller} (the master collection of action handler functions, the extended controller of fiori element templates if necessary).

Last but not least, the \textbf{annotations} collect the cds annotations on the entities, which are combined with the base templates during the rendering.
Those annotations, based on their usages / effects, are put into three cds files (\textbf{labels.cds, ui.cds, value-help.cds}) and are aggregated with an \textbf{index.cds} file.
The following customizations are done using the annotations:

\begin{compactenum}
    \item Label text of properties of displayed entities.
    \item Displayed filters and fields. (default/non-default/hidden)
    \item Highlighting/linking/quick previews of fields.
    \item Define section facets/components of templates.
    \item Value helps for property filters.
    \item Quick variant based on fields values.
\end{compactenum}

\subsubsection{File Structure}

A generic file structure of the UI part is displayed below to help visualizing the folder partitions: 

\lstset{caption={File locations - UI}, label=src:14}
\begin{lstlisting}[language={bash}]
root/
    |- app/
        |- <entity|action> # Generic template UI
            |- webapp
                |- ext
                    |- component 
                    |- controller
                    |- view
                |- i18n
                |- localService
                |- test
                |- Conponent.js
                |- index.html
                |- manifest.json
                |- *css 
            |- annotations
                |- index.cds
                |- labels.cds
                |- ui.cds
                |- value-help.cds
            |- * # other config file for deployment
        |- <entity|action> # Generic freestyle UI
            |- webapp
                |- controller
                |- css
                |- i18n
                |- localService
                |- model
                |- test
                |- Conponent.js
                |- index.html
                |- manifest.json
            |- * # other config file for deployment
        |- appconfig # UIs' config for Fiori Launchpad sandbox.
            |- fioriSandboxConfig.json # Defines how the UI apps are dispalyed and navigated.
        |- index.html # Entry point of launchpad.
        |- service.cds
\end{lstlisting}

\subsection{Manage Storage}
\label{subsec:dev-ui-ms}

Manage Storage is an utility for facility managers to maintain the information regarding the possible storage and slots storing the packages and is a template UI (see \autoref{subsec:ms} for more information on the UX).
The application consumes the \textbf{StorageService} back-end service (\autoref{subsec:back-ms}).
The implementation of the app
located in the \textbf{managestorage} module and under the name space of
\textbf{com.sap.internal.digitallab.packagehandling.app.manage.storages}.
Entity \textbf{Storage} is used as main OData entity and \textbf{StorageSlot} as the child entity.
List Report and Object Page are defined for storage and List Report is defined for slots. The navigation logic of the pages flows like this: \textit{List Report of storage} navigates to \textit{Object Page of storage}, which contains \textit{Line Items of 
slots}, from which the \textit{Object Page of slot} can be navigated to.

\subsubsection{Annotations}
Labels are defined for every properties of exposed entities by the back-end service. Filter value helps are defined for \textbf{Building Floor} and \textbf{Building}.
Line items and facets, filters displays are customized for storage and slot.

\subsubsection{Extension}

Besides the standard app master controller, a Fiori object page extended controller is also added to enable the handling of the custom column buttons on the storage object page. The map column is added as a column fragment to be rendered as a link to external site.

\bigskip
\noindent
The following dialog fragments are implemented:
\begin{compactenum}
    \item Slot creation dialog
    \item Storage creation dialog
    \item Slot edit dialog
    \item Storage edit dialog
    \item Slot mass creation dialog
\end{compactenum}
\bigskip
\noindent
The following components are implemented:
\begin{compactenum}
    \item Slot creation dialog controller
    \item Storage creation dialog controller
    \item Slot edit dialog controller
    \item Storage edit dialog controller
    \item Slot mass creation dialog controller
    \item Slot deletion message box controller
\end{compactenum}


\subsection{Manage Company}
\label{subsec:dev-ui-mc}

Manage Company is an utility for facility managers to maintain the information regarding the possible companies delivering the packages and is a template UI (see related UX in \autoref{subsec:mc}).
The application consumes the \textbf{CompanyService} back-end services (\autoref{subsec:back-mc}).
The implementation of the app
located in the \textbf{managecompany} module and under the name space of
\textbf{com.sap.internal.digitallab.packagehandling.app.manage.companies}.
Entity \textbf{DeliveryCompany} exposed by  \textbf{CompanyService} is used as main OData entity.
List Report and Object Page are defined for companies.
The navigation logic of the pages flows like this: 
\textit{List Report of companies} navigates to \textit{Object Page of company}.

\subsubsection{Annotations}
Labels are defined for every properties of \textbf{DeliveryCompany} exposed by \textbf{CompanyService}. 
Line items, facets, filters displays are customized.

\subsubsection{Extension}

A master app controller is implemented.
Two dialog fragments are implemented in couple with their own dialog components for the creation and edition of the companies. Finally, a column fragment displaying together the company logo and name is added and a style.css cascading style sheets is used for its styling. 

\subsection{Manage Package}
\label{subsec:dev-ui-mp}

Manage Package is the app for packages managements within package handling solution and is a template UI (see related UX in \autoref{subsec:mp}).
The application consumes the \textbf{PackageService} back-end services (\autoref{subsec:back-mp}).
The implementation of the app
located in the \textbf{managepackage} module and under the name space of
\textbf{com.sap.internal.digitallab.packagehandling.app.manage.package}.
The entity \textbf{Package} exposed by  \textbf{PackageService} is used as main OData entity.
List Report and Object Page are defined for packages: \textit{List Report of packages} navigates to \textit{Object Page of package}.

\subsubsection{Annotations}
Labels are defined for every properties of entities exposed by \textbf{PackageService} (StorageSlot, Storage, Package, Building, BuildingFloor, PackageType, PackageStatus, DeliveryCompany, User). 
Filter value helps are defined for \textbf{PackageType}, \textbf{Storage}, \textbf{PackageStatus}, \textbf{DeliveryCompany}, \textbf{Building Floor} as drop downs.
Line items, facets, filters displays are customized.
Contact card is defined for \textbf{User}.
Three variants (new, confirmed, picked up) are defined based on the status of the \textbf{Package} entity.

\subsubsection{Extension}

A master controller is implemented collecting all handlers of custom actions. Two dialog fragments are added with their corresponding components (controllers) for the confirmation and edition of the packages. An extra component reusing the standard message box from UI5 library is also included for the option to pickup a package. 
A cascading style sheet  is added for the styling of column fragments.


\bigskip
\noindent
List of column fragments that are added:
\begin{compactenum}
    \item Company column displays company logo and name.
    \item Location columns displays combined storage and slot.
    \item Type column displays type with icon.
\end{compactenum}


\subsection{Register Package}
\label{subsec:dev-ui-rp}

Register Package is the app for packages managements within package handling solution and is a single-page freestyle UI (see related UX in \autoref{subsec:rp}).
The application consumes the \textbf{RegistrationService} back-end services (\autoref{subsec:back-rp}).
The implementation of the app
located in the \textbf{registerpackage} module and under the name space of
\textbf{com.sap.internal.digitallab.packagehandling.app.register.packages}.

\subsubsection{Models}
The default model of the application is the OData model based on the \textbf{RegistrationService}. There is also a local json model \textbf{"localData"} which stores the dynamic package data and is bound to the package registration form.

\subsubsection{Controllers}
There are two controllers used by the application. \textbf{App.controller.js} is the framework's standard central controller. \textbf{Registration.controller.js} contains all the application logic.

\subsubsection{Views}
There are two views used by the application. \textbf{App.view.xml} acts as the entry point of the application binding to the \textbf{App.controller.js} controller. \textbf{Registration.view.xml} contains the xml annotations of the registration page, binds to \textbf{Registration.controller.js} controller, and acts as the entry page of the application (rendered as the template when entering the application).

\subsection{Pickup Package}
\label{subsec:dev-ui-pp}

Pickup Package is the app for all end users to pick a confirmed package. It consumes the \textbf{PickupService} from the back-end services (\autoref{subsec:back-pp}) and is a two-screen freestyle UI5 application (see related UX in \autoref{subsec:pp}). The implementation of the app located in the \textbf{pickuppackage} module and under the name space of \textbf{com.sap.internal.digitallab.packagehandling.app.pickup.package}.

\subsubsection{Models}
The default model of the application is the OData model based on the \textbf{PickupService}. Local json model \textbf{"usr"} stores the dynamic user data. Local json model \textbf{"packages"} stores the freshest count of the retrieved packages from the \textbf{PickupService}. Both are bound by the overview and done views of the application.

\subsubsection{Controllers}
There are three controllers used by the application. \textbf{App.controller.js} is the framework's standard central controller. \textbf{Overview.controller.js} and \textbf{Done.controller.js} contain the application logic of corresponding pages.

The application also utilized the standard message box component from the framework, whose handler is implemented under \textbf{component} folder.

\subsubsection{Views}
There are three views used by the application. \textbf{App.view.xml} acts as the entry point of the application bound to the \textbf{App.controller.js} controller. \textbf{Overview.view.xml} contains the xml annotations of the Overview page, binds to \textbf{Overview.controller.js} controller, and acts as the entry page of the application (rendered as the template when entering the application). \textbf{Done.view.xml} contains the xml annotations of the post pickup page. The navigation between two view is enabled with action buttons.

\subsection{My Package}
\label{subsec:dev-ui-ph}

My Package is the app for packages managements within package handling solution and it is a one page template UI (see related UX in \autoref{subsec:ph}).
The application consumes the \textbf{HistoryService} back-end services (\autoref{subsec:back-ph}).
The implementation of the app
located in the \textbf{browsepackage} module and under the name space of
\textbf{com.sap.internal.digitallab.packagehandling.app.browse.package}.
The entity \textbf{Package} exposed by  \textbf{HistoryService} is used as main OData entity.
List Report is defined for packages.

\subsubsection{Annotations}
Labels are defined for every properties of entities exposed by \textbf{HistoryService} (StorageSlot, Package, PackageType, PackageStatus, DeliveryCompany). 
Filter value helps are defined for \textbf{PackageType}, \textbf{PackageStatus}, \textbf{DeliveryCompany} as drop downs.
Line items, filters displays are adjusted.

\subsubsection{Extension}

The My Package UI contains two column fragments and a cascading style sheet used by the fragments.

\bigskip
\noindent
List of the column fragments that are added:
\begin{compactenum}
    \item Company column displays company logo and name.
    \item Type column displays type with icon.
\end{compactenum}



\section{Services}
\label{sec:D-srv}

As mentioned in \autoref{sec:D-AppStructure}, 6 OData end-points are maintained by the back-end. This section will first give an overview of the overall architecture and technology used (\autoref{subsec:D-srv-back-arch}), then it will give more detailed and specific information on each of the services.

\subsection{Back-end Architecture Overview}
\label{subsec:D-srv-back-arch}

The implementation of back-end services are done using a combination of two languages: CDL (CDS' definition language) \cite{cap-cds-lang} and Java \cite{java}. The concrete implementations are located under the \textit{/srv} folder as illustrated in \autoref{src:15}, in which the underneath components are further explained in \autoref{subsubsec:D-srv-design}. Before that, the general steps/requirements of implementing a service can be checked in \autoref{subsubsec:D-srv-steps}. 

\lstset{caption={Directories guide - Back-end}, label=src:15}
\begin{lstlisting}[language={bash}]
root/
    |- srv/
        |- src # Java codes for custom business logics
            |- main/java/com/sap/internal/digitallab/
                |- packagehandling
                    |- handlers
                        |- <ServiceName>Handler.java
                    |- managers
                        |- <EntityName>Manager.java
                    |- repositories
                        |- <EntityName>Repository.java
        |- gen # generated java codes from CDS views
        |- services # Service definitions in CDS annotation
            |- ServiceName 
                |- *.cds # otehr definition of service
                |- *-auth.cds # Access restriction on roles.
\end{lstlisting}

\subsubsection{General Steps of Implementation}
\label{subsubsec:D-srv-steps}

The \textbf{first step} of implementing any service is to define its CDS view using CDL, which provides instructions on:
\begin{compactenum}
	\item The data model in database to be exposed by the service.
	\item The desired input validations.
	\item The capabilites of action controls.
    \item The role restrictions on the access of the services.
    \item (Optional) actions and functions dedicated to the service.
\end{compactenum}
At compilation time, those service definitions will be translated into HANA SQL views and will be inserted into the \textit{schema.sql} file, together with data model table definitions (see \autoref{subsec:db-cdl})
\bigskip

The \textbf{second step} is implementing the business logic using Java. CAP project provides a out-of-box default implementation of simple CRUD \cite{crud} operations, in some cases shall be override/replaced. In most of the cases it involves explicit interactions with the persistence service and in this case a Java supported CQN (Core Query Notation) \cite{cap-cds-cqn} is used. The Java codes should applies the following:
\begin{compactenum}
	\item Implementations of custom CRUD operations
	\item Implementations of virtual fields calculations
	\item Implementations of actions and functions defined in CDS view.
\end{compactenum}

\bigskip
To support debugging, a \textbf{Logger} is added to every class to provide logging statements.

\lstset{caption={Logger - Backend}, label=src:2009}
\begin{lstlisting}[language={java}]
 private static final Logger LOGGER = LoggerFactory.getLogger("name_logger");
\end{lstlisting}

\bigskip
To fully understand how to write these implementations, the developer should first recognize the \textit{srv/gen} folder, which contains generated Java codes by cds builder. Here we list the very necessary background knowledge and factors of the generated code, before continuing with implementations. 
\begin{compactenum}
	\item \textit{srv/gen} folder is generated from all the \textit{*.cds} files using in the \textit{index.cds} (recursively used), for an entity or a service definition.
    \item The generated code are in Java and are under the same package domain as specified in namespace of the \textit{*.cds} files.
    \item For each entity and service a couple of \textit{EntityName.java} and \textit{EntityName\_.java} interface being generated. 
    \item The developer can use \textit{EntityName\_.CDS\_NAME} in case of the need to clarify the usage of certain entity or service. Also \textit{EntityName\_.class} in CQN as an analogy of table names. 
    \item The developer should use \textit{EntityName} in case of the usage of the real entity or service, similar to object model in JPA \cite{jpa}. Also in the case of CQN, constants of column names can be retrieved as static fields like this: \textit{EntityName.COLUMN\_NAME}, which should be encouraged over giving string expressions.
\end{compactenum}

\bigskip
It is also important to understand the event processing of CAP. CAP provides out-of-box handling of CRUD event for every entity and the costume logics are implemented using the idea: what should happen before, on and after the event, with the help of method annotation \textbf{@Before, @On, @After}. Methods annotated with \textbf{@Before} and \textbf{@After}, as the name suggested, implements preprocessing and postprocessing logic. \textbf{@On} can be seen as an override of the origin defalut implementation of the event. For a custom event or action, it is obligatory to provide an \textbf{@On} method.

\subsubsection{Architecture Design}
\label{subsubsec:D-srv-design}

The back-end architecture follows the recommendations of CAP \cite{cap-java-architecture}, Spring MVC \cite{spring-mvc} and microservices architecture principles. Its implementation is divided into 3 layers: handlers, managers and repositories. Upon a OData service request, queries are forwarded to the so called Consumption API which then triggers the generic event handlers of CAP passing a so called event context. At this point, handler layers came into play and dispatch the tasks associated with the event to manager layers, where business logics (processing/caculations) are coded. In case of a interaction with database models, the processing is delegated to the repository layer, which implements sets of database related operations at Java level using CQL (CDS Query Language) \cite{cap-cds-cql} communicating with CQN execution engine (\autoref{fig:backArch}). 

\begin{figure}[!htb]
	\centering
	\includegraphics[height=400px]{images/backend_architecture.png}
	\caption{Back-end architecture}
	\label{fig:backArch}
\end{figure}

The blocks in blue of the above \autoref{fig:backArch} indicates the necessary Java implementation parts. 
In the handler layer, a \textit{<ServiceName>ServiceHandler} class is defined for every service and each handler implements the \textbf{EventHandler} \cite{cap-java-event-handler} from cds's came along package \textit{com.sap.cds.services.handler}. This ensures that the handler class will be fed with received events from the Consuming API. Also a Java annotation \textbf{@ServiceName(SomeService\_.CDS\_NAME)} is added at class level, to provide information on which service the handler is handling. The handlers classes are also marked with \textbf{@Component} annotation from the spring framework as a Bean, to get the most out of Spring-boot \cite{springboot-doc}'s dependency control. A base skeleton of handler class is embedded in \autoref{src:2008}.

\lstset{caption={Handler skeleton - Backend}, label=src:2008}
\begin{lstlisting}[language={java}]
@Component
@ServiceName(EnvolvedService_.CDS_NAME)
public class EnvolvedServiceHandler implements EventHandler { }
\end{lstlisting}

In case of necessary usage of manager layer, private field and auto-wired constructor injection combination is used, as supported by the spring-boot framework. See a base skeleton of class association (composition in spring-boot implementation aspect) in \autoref{src:2018}.

\lstset{caption={Association class skeleton - Backend}, label=src:2018}
\begin{lstlisting}[language={java}]
private final UsedEntityManager manager;

@Autowired
public CompanyServiceHandler(UsedEntityManager manager) {
    this.manager = manager;
}
\end{lstlisting}

To explicitly watch an event (CRUD, custom events/actions/functions), methods should look like in \autoref{src:2019}.
\lstset{caption={Listening method skeleton - Backend}, label=src:2019}
\begin{lstlisting}[language={java}]
@After(event = {CqnService.EVENT_DELETE})
public void afterDeleteEvent(EventContext context) { }
\end{lstlisting}

\bigskip
In the manager layer, a \textit{<EntityName>Manager} class is defined for every entities. Each class contains entity related methods to support the services. It holds every required calculations, processing, business logics partitioned by entities. It can be more or less analog to the service layer in a normal back-end spring-boot application.
See a base skeleton of manager class in \autoref{src:3000}.

 \lstset{caption={Manager class skeleton - Backend}, label=src:3000}
\begin{lstlisting}[language={java}]
@Component
public class OneEntityManager {
    private final OneEntityRepository repo1;
    private final OneOtherEntityRepository repo2;
    private final OtherEntityManager mgr;
    ...
    @Autowired
    public PackageManager(OneEntityRepository repo1, OneOtherEntityRepository repo2, OtherEntityManager mgr) {
        this.repo1 = repo1;
        this.repo2 = repo2;
        this.mgr = mgr;
    }
    public void someMethodHandlingTheRequestsFromHandlerClass() {}
    private void someHelperMethod() {}
}
\end{lstlisting}


\bigskip
In the repository layer, a \textit{<EntityName>Repository} class is defined for every entities. This layer can be seen as the model layer in MVC architecture. It is responsible for any direct interaction with the database. In CAP, the connection to database is provided through a persistence service implementation (\textbf{com.sap.cds.services.persistence.PersistenceService}) so that different databases (sqlite at development environment, HANA at deployment) can be used and switched seamless. CQN builders are also provided under \textbf{com.sap.cds.ql.cqn} supporting a SQL like syntax for building a SQL statement in Java.
A base skeleton of repository class is shown in \autoref{src:3202}.
To interacted with the database, a CQN example is provided in \autoref{src:3001}.

 \lstset{caption={Repository class skeleton - Backend}, label=src:3202}
\begin{lstlisting}[language={java}]
@Component
public class DeliveryCompanyRepository {
    private final PersistenceService db;

    @Autowired
    public DeliveryCompanyRepository(PersistenceService db) {
        this.db = db;
    }
}
\end{lstlisting}

 \lstset{caption={CQN method skeleton - Backend}, label=src:3001}
\begin{lstlisting}[language={java}]
/**
 * SELECT * FROM delivery_company WHERE id = $id;
 *
 * @param id company UUID to check.
 * @return resulting rows
 */
public Result selectById(String id) {
    CqnSelect select = Select
            .from(DeliveryCompany_.class)
            .byId(id);
    return db.run(select);
}
\end{lstlisting}

So far the explanation on the technical stack of the back-end implementations is finished. The specification of each services follows.


\subsection{Storage Service}
\label{subsec:back-ms}

Storage service has the purpose of holding information on the possible storage places and keep track of the usages of single storage slots with the storage (see more details of the business logic in \autoref{subsec:ms}). 

\subsubsection{CDS View}

\noindent
List of entities being exposed by the service:
\begin{compactenum}
	\item Storage (*)
    \item StorageSlot (*)
    \item Building (id, name, map, address, coordinates, phoneNumber)
    \item BuidingFloor (id, name, map, building)
    \item SlotStatus (*)
\end{compactenum}

\bigskip
In the service's CDS view, the association (foreign key validation) is reinforced by \textbf{@assert.target} on \textbf{StorageSlot.storage}, which will check the existence of the foreign key at runtime.
 The input invalidation checks are also defined for mandatory fields using \textbf{@mandatory} annotation. This ensures the rejection of creation in case of missing fields.

\bigskip
\noindent
List of mandatory fields of storage service:
\begin{compactenum}
	\item Storage.name
    \item Storage.buildingFloor
    \item StorageSlot.name
    \item StorageSlot.storage
\end{compactenum}

\bigskip
\textbf{Note}: Storage.buildingFloor is not checked as a foreign key here, because in the plan its reference should be replaced by a central data service.


A custom action \textit{massCreate} is implemented, which creates multiple slots at one shot. The implementation also watches the read events of \textbf{Storage} and \textbf{StorageSlot}, after which virtual fields (\textit{total packages}, \textit{current packages}) and virtual action control fields (\textit{delete ac}) are calculated dynamically.

\subsubsection{Java}

Classes and methods related to storage service are illustrated in the UML (\autoref{fig:storage_service_uml}). Private utility methods are ignored for the sake of simplicity.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/service_class_diagrams/storage_service_class_diagram.png}
    \caption{Storage Service UML}
    \label{fig:storage_service_uml}
\end{figure}

\subsection{Company Service}
\label{subsec:back-mc}

Company service provides the possibilities for facaulty managers and administrators to CRUD the delivery companies and is exposed under the end-point \textbf{CompanySerive} (see more details of the business logic in \autoref{subsec:mc}).

\subsubsection{CDS View}
The company service exposes only one entity, \textbf{DeliveryCompany}, with all of its fields.
The input invalidation checks are defined for the projected \textbf{name} field of the \textbf{DeliveryCompany} using \textbf{@mandatory} annotation. This ensures the rejection of creation in case of missing fields. 

CRUD are supported for a single delivery company entity. Custom Java code ensures the relevant packages' references to the company are deleted seamlessly upon the deletion of the company.

\subsubsection{Java}

Classes and methods related to storage service is illustrated in the UML (\autoref{fig:company_service_uml}). Private utility methods are ignored for the sake of simplicity.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/service_class_diagrams/company_service_class_diagram.png}
    \caption{Company Service UML}
    \label{fig:company_service_uml}
\end{figure}


% -------------------------------------
%  Package service
%  -----------------------------------
\subsection{Package Service}
\label{subsec:back-mp}

Package service provides receptionists, faculty managers and administrators the abilities to update and delete a package and reads its related information (see more details of the business logic in \autoref{subsec:mp}). It is exposed at OData end-point \textit{PackageService}.

\subsubsection{CDS View}

\noindent
List of entities being exposed by the service:
\begin{compactenum}
	\item Package (*)
    \item PackageType (*)
    \item PackageStatus (*)
    \item Storage (id, name, buildingFloor)
    \item StorageSlot (id, name, storage, status)
    \item DeliveryCompany (ID, name, logo)
    \item Building (ID, name, floors)
    \item BuildingFloor (ID, name, building)
    \item Receptionist (*)
    \item User (*)
\end{compactenum}

\bigskip
The association (foreign key validation) is reinforced by \textbf{@assert.target} on \textbf{Package.type}, which implies the checking of the existence of the foreign key at runtime. The input invalidation checks are defined for mandatory fields using \textbf{@mandatory} annotation. This ensures the rejection of creation in case of missing fields. 

\bigskip
\noindent
Mandatory fields of package service:
\begin{compactenum}
	\item Package.recipient
    \item Package.type
    \item Package.receptionist
\end{compactenum}


\bigskip
Two custom unbounded actions \textit{confirm} and \textit{pickup} are also defined in the CDS view, to facilitate the confirmation of a package (new -> confirmed) and the picked-up possibility of a package by a facility manager and administrator (confirmed -> pickup). Two action controls, \textit{confirm\_ac} and \textit{pickup\_ac} then are introduced coupling with the previous two actions, to make sure that the action button will only be available at desired time at the UI level. The bound is implemented with the \textit{@Capabilities} annotation. Furthermore, a delete action control is added on the package entity, which shall be activated only when a package is of status new / confirmed. This controls the activation of "delete" button at UI level specified by the \textit{@Capabilities} annotation. 


An useful detail here is that, the pickup action in the package service shall be used by receptionist and facility manager only, when the end-user cannot access to the pickup service (see business scenario in \autoref{subsec:mp}). While both service have the same pickup action, the \textit{pickup\_ac} in package is shared by the two service.

Read, update and delete possibilities of an package entity are guaranteed by the package service. For the other exposed entities, only read possibility is allowed. The reinforcement of CRUD capabilities can be checked in the \textbf{PackageService.cds}. 

An useful reminder here is that, the create operation of the package is missing in this service, as there is a separated registration service which is only responsible for the creation of new package, which will be detailed later.

\subsubsection{Java}

The realization of the calculations of action control and the custom behaviour of actions are done in the Java part. The related classes and methods can be checked in the UML (\autoref{appx:diagram} -\autoref{fig:package_service_uml}). 


% -------------------------------------
%  Registration service
%  -----------------------------------
\subsection{Registration Service}
\label{subsec:back-rp}

Registration service provides receptionists, faculty managers and administrators the abilities to create (register) a package and reads its related information (see more details of the business logic in \autoref{subsec:rp}). 
It is exposed at OData end-point \textit{RegistrationService}. 

\subsubsection{CDS View}

\noindent
List of entities being exposed by the service are:
\begin{compactenum}
	\item Package (*)
    \item PackageType (*)
    \item PackageStatus (*)
    \item DeliveryCompany (id, name)
    \item Receptionist (*)
    \item User (*)
\end{compactenum}

\bigskip
The same set of special annotations (\textbf{@mandatory}, \textbf{@assert.target}) are defined for the same projected properties for the registration service as the package service (\autoref{subsec:back-mp}).

Creating the possibility of a package entity is guaranteed by the registration service (other operations are implemented already in the package service (\autoref{subsec:back-mp})). For the other exposed entities, only the read possibility is allowed. 

\subsubsection{Java}

No actions or action controls are defined for the registration service. Only a pre-processing (pre-filling the package status to new) is implemented at Java level and a simple handler class is pretty much all one would need. Nevertheless, the related classes and methods can be checked in the UML (\autoref{fig:registration_service_uml}). 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/service_class_diagrams/registration_service_class_diagram.png}
    \caption{Registration Service UML}
    \label{fig:registration_service_uml}
\end{figure}
%\pagebreak




% -------------------------------------
%  Pickup service
%  -----------------------------------
\subsection{Pickup Service}
\label{subsec:back-pp}

While the previous 4 services focuses on administration topics and can be accessed only by nominated roles, the finally 2 service are opened to all end-users with a proper company device. One of them is the pickup service. As the name suggest, it provides any authenticated user the abilities to check and pickup his or her own confirmed package at the reception (see more details of the business logic in \autoref{subsec:pp}). It is exposed at OData end-point \textit{PickupService}. 

\subsubsection{CDS View}

Entities being exposed in this service is almost the same as in the package service, with a little bit of reduction, providing user with just enough necessary information. 

\bigskip
\noindent
List of entities exposed by the service:
\begin{compactenum}
	\item Package (*)
    \item PackageType (*)
    \item PackageStatus (*)
    \item Storage (id, name, locationInstructions)
    \item StorageSlot (id, name)
    \item DeliveryCompany (id, name)
\end{compactenum}

\bigskip
In the service's CDS view, no input invalidation checks are defined, as the user will not be able to change anything, other than click a confirm pickup button. This is reinforced by limiting the CRUD possibilities - only read operation is supported for any entity. As for the future pickup button, an action \textit{pickup} is defined. Its entanglement with the \textit{pickup\_ac} used by package service are discussed in \autoref{subsec:back-mp}.


\subsubsection{Java}

A default filter read operation and the custom action are implemented in the Java part. The pickup action itself basically reuse the same methods as the package service does. The related classes and methods can be checked in the UML (\autoref{appx:diagram} - \autoref{fig:pickup_service_uml}). 


% -------------------------------------
%  History service
%  -----------------------------------
\subsection{History Service}
\label{subsec:back-ph}

History service is used by any authenticated user to check their package history (see more details of the business logic in \autoref{subsec:ph}) and it is exposed at OData end-point \textit{HistoryService}.

\subsubsection{CDS View}

Entities being exposed in this service is almost the same as in the registration service, with every details, providing user with as much information as could. The entities exposed by the service are:
\begin{compactenum}
	\item Package (*)
    \item PackageType (*)
    \item PackageStatus (*)
    \item DeliveryCompany (*)
    \item Receptionist (*)
    \item User (*)
\end{compactenum}

\bigskip
In the service's CDS view, no input invalidation checks are defined, as the user will not be able to change anything. A restriction is made so that the user can only read his or her own package through a \textit{where} statement in the projection view.

For all exposed entities, only read operation is supported. This is enforced by a \textit{@readonly} annotation on every entity projection.

\subsection*{Quick Wrap Up}
Hereby the introduction of the core implementation part of \autoref{ch:impl} is completed.
In the coming \autoref{sec:D-security} and \autoref{sec:D-testing}, the security aspects and the testing approaches for the project are explained in detail.

\section{Security}
\label{sec:D-security}

The project is developed for internal use of SAP and can be accessed only from SAP devices. 
Authorization of the project is enforced through a role based accessibility to the specific services. Four roles are defined, namely Administrator, Facility Manager, Receptionist and End-User. The assignment of roles will be done centrally on the Business Technology Platform (BTP) upon deployment. As for local development, mock users are defined in \textit{<path-to>/application.yaml} in case of running as spring boot \cite{springboot-doc} application.

\subsection{Roles Specification}
The role-base access restriction on services are defined in \textit{root/srv/services/*-auth.cds} files using cds annotations. Bellow illustrated the exact locations of the auth files.

\lstset{caption={File locations - Security}, label=src:12}
\begin{lstlisting}[language={bash}]
root/
    |- srv/
        |- services
            |- ServiceName 
                |- *.cds # Definition of service
                |- *-auth.cds # Access restriction on roles.
    |- xs-security.json # list of roles
\end{lstlisting}

The specific meaning of the roles can be found in the user's documentation in \autoref{sec:GeneralRequisite}. The access rules of the 4 roles are summarized below:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|m{2.1cm}|m{2.1cm}|m{2.1cm}|m{2.5cm}|} \hline 
         & End-User & Receptionist & Facility Manager & Administrator     \\ \hline 
         Manage Storage          & No & No & Yes & Yes \\ \hline 
         Manage Companies         & No & No & Yes & Yes \\ \hline 
         Manage Packages          & No & Yes & No  & Yes \\ \hline 
         Register Package       & No & Yes & No  & Yes \\ \hline 
         Pickup Package           & Yes & Yes & Yes & Yes \\ \hline
         My Package               & Yes & Yes & Yes & Yes \\ \hline
    \end{tabular}
    \caption{Roles Access Rules}
    \label{tab:Access Rule}
\end{table}
\subsection{Mock Users}

The following mock users are set up in the development and test profiles for the local development and testing:

\begin{table}[H]
    \centering
    \begin{tabular}{|m{2.5cm}|m{2.5cm}|m{3.5cm}|m{2.5cm}|} \hline 
        \textbf{Name/ID} & \textbf{Password} & \textbf{Role(s)} & \textbf{Profile} \\ \hline 
        admin & admin & Administrator & test \\ \hline 
        I123456 & admin & Administrator & default \\ \hline
        manager & manager & FacilityManager & test \\ \hline 
        I234567 & manager & FacilityManager & default \\ \hline 
        recep & recep & Receptionist & test \\ \hline 
        C456789 & recep & Receptionist & default \\ \hline 
        I333333 & user & User & test \\ \hline
        I111111 & user & User & test, default \\ \hline 
    \end{tabular}
    \caption{Mock Users for Local Testing \& Development}
\end{table}

\section{Testing}
\label{sec:D-testing}

This last section of \autoref{ch:impl} focuses on project tests. First the locations of mock/test data are introduced (\autoref{subsec:test-data}). This is followed by \autoref{subsec:test-unit} for unit testing and \autoref{subsec:test-api} on the integration/api tests. In \autoref{subsec:test-exe} how to run and what is the result of the tests are explained. Finally in \autoref{subsec:test-ui} some manual test cases on UI are listed, which may provide an idea of the exact functions that are currently supported by the project. By the end of this section, a developer shall get a full overview of the used test framework and should be able to extend the test cases based on the existing ones.

\subsection{Test Data}
\label{subsec:test-data}
In a CAP application, under development environment, test data is provided in the format of csv \cite{csv} files. The first line of any csv collects the properties of data model (only those stored physically in database, see \autoref{sec:D-db}). The csv files are named in the format: <namespace>-<EntityName>.csv. Empty csv files (with only the first line) can be generated by the command \textit{cds add data}, which can then can be found in the \textit{/db/data/} folder. Later on the records of data can be appended to those csv files.

The csv files containing the test data for this thesis are located in two locations exclusively (i.e. no records of entry are repeated). The test data for any code list entities are located in \textit{/db/data/*.csv}, as they are fixed and final values and will be also loaded on deployment. The test data for other entites are located in \textit{/test/data/*.csv}. The entries here will only be loaded into database under local environment and will be ignored when deploying.

A test dedicated spring application environment is also defined in the \textit{application.yaml}. The main reason behind is that the loading path of the initial data is different in the two environment. The two profiles also define different mock users.
The additional property-value pairs can be checked in \autoref{tab:property-values}.

\begin{table}[ht]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Property} & \textbf{Value} \\
\hline
cds.csv.paths & ../test/data/** \\
cds.security.mock.users.my\_uname & password: my-password \\
cds.security.mock.users.my\_uname & roles: - my-role \\
\hline
\end{tabular}
\caption{Description of Properties and Values}
\label{tab:property-values}
\end{table}


\subsection{Unit Testing}
\label{subsec:test-unit}

Unit testing \cite{unit-test} of this project focuses on the methods and line coverage of the manager and the repository layer (See \autoref{sec:D-AppStructure}). JUnit 4 \cite{junit} and spring test \cite{spring-testing} stater pack is used to write the tests. The unit tests located under maven's default \textit{test/java} folder. 

A test class is created for each used class in the manager and repository layer. Those who are merely a placeholder for structure usages are ignored. The test classes are created almost at the same time with the implementations. The implementations of both happen in an iterative way: test cases are created based on code and requirements, code is fixed based on test results, test cases evolve based on the modified code, and so on. Each test class is written under the following logic. (See \autoref{src:150} for a sample skeleton of a unit test class.)

\begin{compactenum}
    \item An auto wired instance of the manager or repository class.
    \item 1..many test cases for each public method.
    \item Each test case calls a method and assert a desired output depends on the initial data in the csv files.
    \item Intellij coverage test is executed at the end of implementation to ensure every branch / edge cases are covered.
\end{compactenum}

\bigskip
\textbf{Extending Advice:} In case of any needs in the future that more test shall be added, it is advised to append completely new dedicated test data sets into csv. Deleting or removing the existing data set can result in sever collapse of the current tests.

\autoref{fig:ut_uml_mgr} and \autoref{fig:ut_uml_repo} contains the UMLs of test classes for the manager and repository layers, where the test cases can be deduced from the name of test methods at a glance. The test classes themselves do not have any dependencies or relations with another, except for their dependency on the manager or repository class that they are testing. These relations are not shown on the attached UML.

\lstset{caption={Unit Test Skeleton - Testing}, label=src:150}
\begin{lstlisting}[language={java}]
@SpringBootTest
@ActiveProfiles("test")
class EntityNameRepositoryTest {
    private final EntityNameRepository repo; // tested instance
    
    @Autowired // constructor injection
    EntityNameRepositoryTest(EntityNameRepository repo) {
        this.repo = repo; 
    }

    @Test
    void testMethodName() {
        repo.methodName();
        Assertions.assertEquals(..., ...);
    }
}
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/test/manager_tests.png}
    \caption{Unit Tests UML - Manager Tests}
    \label{fig:ut_uml_mgr}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{images/test/repository_tests_white.png}
    \caption{Unit Tests UML - Repository Tests}
    \label{fig:ut_uml_repo}
\end{figure}


\subsection{Integration Testing}
\label{subsec:test-api}

Integration testing of this project focuses on the correctness of the http connections back-end services, that is, on the handler layer. \textbf{Rest Assure} \cite{test-rest-asstured} api testing framework is used in this scenario. (See a sample api request using \textbf{Rest Assured} framework in \autoref{src:500}.)

\bigskip
\lstset{caption={Sample Rest Assured Request - Testing}, label=src:500}
\begin{lstlisting}[language={java}]
given()  
	.auth().preemptive().basic("admin", "admin") // Authorization
	.contentType("application/json")  // request body type
	.body("{" + "}")  // request body
.when()  
	.post("http://localhost:" + port + "serviceUrl")  // request url
.then()  
	.statusCode(201) // check the return status
	.body("field", Matchers.equalTo("something")); //check the return body
\end{lstlisting}

The integration tests locate under \textit{srv/src/integration-test/java}. The folder has been added to pom file as part of the test routine. A base test class is implemented abstracted all the common necessary setups (ports, user entry, testing utility methods) (\autoref{src:501}). 

\bigskip
\lstset{caption={Integration Test Base Skeleton - Testing}, label=src:501}
\begin{lstlisting}[language={java}]
@SpringBootTest(  
        webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT  
)  // This generate a random port for the app every run time 
public class BaseServiceTest {  
    protected String host = "http://localhost:"; 
    @LocalServerPort  
    protected Integer port; // access the random port

    // User map initializations...
    // CRUD methods...
    // CRUD and status checking methods...
}
\end{lstlisting}


One integration test class is then created for each service with the name \textbf{<ServiceName>Test.java} and extends from the base test class (see skeleton in \autoref{src:502}). 

\lstset{caption={Integration Test Child Skeleton - Testing}, label=src:502}
\begin{lstlisting}[language={java}]
public class SomeServiceTest extends BaseServiceTest {

	@Test
	void test1() {}
	
	@Test
	void test1() {}
	
	...
}
\end{lstlisting}

For each service, the underlying test ideas are followed: (Check also the UML in \autoref{appx:diagram} - \autoref{fig:it_uml} for specific structure and methods of the test classes.)
\begin{compactenum}
	\item Correct access to service based on roles. (returning status code 200/403).
    \item Correct restrictions of CRUD operation (returning status code 200/201/ 204/409/405).
    \item Expected results of the action imports (returning status code 200 and results checking).
    \item Expected results of any customized CRUD operations (returning status code 200/201/204/409/405 and results checking).
\end{compactenum}


\subsection{Execution of Tests}
\label{subsec:test-exe}
All the tests can be executed either from command line using \textit{mvn test} in the SAP business application studio or by clicking the test goal in the maven tab of Intellij. The expected results of the execution is shown in \autoref{fig:test_exe}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{images/test/test_results.png}
    \caption{Test Execution Results}
    \label{fig:test_exe}
\end{figure}

\subsection{UI Testing}
\label{subsec:test-ui}

There is not a framework used by the project for UI testing. It is done manually following the below guidelines. For each UI applications, the outlook is first checked (if elements are displayed as expected), then the functions are tested case by case, under the name of different mock users with different roles. 

\noindent
\textbf{Pickup Packages}
\begin{itemize}
    \item User can pickup one package.
    \item User can pickup more than one packages.
    \item After pickup, user is redirected to done page.
    \item Packages information displayed as expected on overview and done page.
    \item Navigation between two pages.
\end{itemize}

\noindent
\textbf{Package History}
\begin{itemize}
    \item All packages of the user displayed as expected.
    \item Filters work as expected.
\end{itemize}

\noindent
\textbf{Manage Package}
\begin{itemize}
    \item Variants work as expected.
    \item Filters work as expected.
    \item User can confirm one or more packages.
    \item When confirming the packages, only available slots are shown.
    \item User can pickup one package at a time.
    \item User can delete \textit{new} and \textit{confirmed} packages.
    \item User can edit packages.
    \item Contact cards display as expected.
\end{itemize}

\noindent
\textbf{Register Package}
\begin{itemize}
    \item User can add register new packages.
    \item User will be redirected to \textbf{Manage Package} application after "Save".
    \item User will be redirected back one page, if there is a history.
\end{itemize}

\noindent
\textbf{Manage Storages}
\begin{itemize}
    \item Filters work as expected.
    \item User can add new storages.
    \item User can (only) delete unused storages.
    \item User can (only) delete unused slots.
    \item User can add slots.
    \item User can mass create slots.
    \item Mass creation input error handling works as expected.
    \item User can edit storages.
    \item User can edit slots.
\end{itemize}

\noindent
\textbf{Manage Companies}
\begin{itemize}
    \item Filters work as expected.
    \item User can add new companies.
    \item User can delete companies.
    \item Deleted companies will disappear also in associated packages.
    \item User can edit companies.
\end{itemize}


% \section{Technologies and Terms}

\section*{Chapter Conclusion}

By the end of \autoref{ch:impl}, a developer would have gained rich knowledge of how the implementations were conducted and should have a brief understanding of all the associated technologies. A developer should at this point be able to understand the complete codes of the projects and be able to extend the project. 

In the coming \autoref{ch:sum}, the thesis is eventually concluded.